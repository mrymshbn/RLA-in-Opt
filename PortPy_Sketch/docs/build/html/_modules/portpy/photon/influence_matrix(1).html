<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>portpy.photon.influence_matrix &mdash; PortPy 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PortPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">portpy</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PortPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">portpy.photon.influence_matrix</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for portpy.photon.influence_matrix</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LinearRing</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Point</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">patchify</span> <span class="kn">import</span> <span class="n">patchify</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>


<div class="viewcode-block" id="InfluenceMatrix"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix">[docs]</a><span class="k">class</span> <span class="nc">InfluenceMatrix</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class of influence matrix</span>

<span class="sd">    - **Attributes** ::</span>

<span class="sd">        :param beamlet_width_mm: The width of each beamlet in millimeters. Default is 2.5. Must be a multiple of 2.5.</span>
<span class="sd">        :param beamlet_height_mm: The height of each beamlet in millimeters. Default is 2.5. Must be a multiple of 2.5.</span>
<span class="sd">        :param down_sample_xyz: A list of integers representing the downsampling factors for the x, y, and z axes. When set to None, the original optimization voxel resolution will be used.</span>
<span class="sd">        :param structure: The target structure for creating the beamlets in the influence matrix. Default is &#39;PTV&#39;.</span>
<span class="sd">        :param opt_voxels_dict: A dictionary containing the voxels that were used in the optimization process.</span>
<span class="sd">        :param beamlets_dict: A dictionary containing the information about beamlets used in the plan.</span>
<span class="sd">        :param opt_beamlets_PTV_margin_mm: A float value representing the margin_mm around the PTV that was used in creating beamlets</span>
<span class="sd">        :param A: influence matrix that is generated by the get_influence_matrix() method.</span>
<span class="sd">        :param dose_3d: 3D dose_1d distribution. It is saved as attribute once the method dose_1d_to_3d() is called</span>
<span class="sd">                so that it doesnt have to be computed again</span>

<span class="sd">    - **Methods** ::</span>
<span class="sd">        :dose_1d_to_3d(sol)</span>
<span class="sd">            Convert dose_1d from 1d to 3d and return dose_1d in 3d</span>
<span class="sd">        :dose_3d_to_1d(dose_3d)</span>
<span class="sd">            Convert dose_1d from 3d to 1d voxels and return dose_1d in 1d</span>
<span class="sd">        :fluence_2d_to_1d(fluence_2d)</span>
<span class="sd">            Create vector of intensities from 2d fluence maps</span>
<span class="sd">        :fluence_1d_to_2d(fluence_1d)</span>
<span class="sd">            From vector of intensities create 2d fluence maps</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan_obj</span><span class="p">,</span>
                 <span class="n">beamlet_width_mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">beamlet_height_mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">opt_vox_xyz_res_mm</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">is_full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">structure</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;PTV&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a influence matrix object for Influence Matrix class based upon beamlet resolution and down-sampling_xyz ratio</span>

<span class="sd">        :param plan_obj: object of class Plan</span>
<span class="sd">        :param beamlet_width_mm: beamlet width in mm. It should be multiple of 2.5, defaults to 2.5</span>
<span class="sd">        :param beamlet_height_mm: beamlet height in mm. It should be multiple of 2.5, defaults to 2.5</span>
<span class="sd">        :param structure: target structure for creating BEV beamlets, defaults to &#39;PTV&#39;</span>
<span class="sd">        :param opt_vox_xyz_res_mm: It down-samples optimization voxels as factor of ct resolution</span>
<span class="sd">                e.g. opt_vox_xyz_res = [5*ct.res.x,5*ct.res.y,1*ct.res.z]. It will down-sample optimization voxels with 5 * ct res. in x direction, 5 * ct res. in y direction and 1*ct res. in z direction.</span>
<span class="sd">                defaults to None. When None it will use the original optimization voxel resolution.</span>
<span class="sd">        :param is_full: Load full or sparse matrix. defaults to False. If True, will load full matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">beamlet_width_mm</span> <span class="o">%</span> <span class="mf">2.5</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">beamlet_height_mm</span> <span class="o">%</span> <span class="mf">2.5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">=</span> <span class="n">beamlet_width_mm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">=</span> <span class="n">beamlet_height_mm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beamlet_width_mm and beamlet_height_mm should be multiple of 2.5&#39;</span><span class="p">)</span>

        <span class="n">down_sample_xyz</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Temporary variable to check if we want to down sample or not</span>
        <span class="k">if</span> <span class="n">opt_vox_xyz_res_mm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">down_sample_xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">opt_vox_xyz_res_mm</span><span class="p">,</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">ct</span><span class="p">[</span><span class="s1">&#39;resolution_xyz_mm&#39;</span><span class="p">])]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">down_sample_xyz</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># if all are 1 then no down sample</span>
                <span class="n">down_sample_xyz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="o">=</span> <span class="n">down_sample_xyz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_full</span> <span class="o">=</span> <span class="n">is_full</span>
        <span class="c1"># create deepcopy of the object or else it will modify the my_plan object</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="p">,</span> <span class="s1">&#39;opt_voxels_dict&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">opt_voxels_dict</span>  <span class="c1"># remove opt_voxels_dict from structures</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">inf_matrix</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;beamlets&#39;</span> <span class="ow">in</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;beamlets&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">inf_matrix</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="s1">&#39;beamlets&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">])):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># save beam_id in beamlet_dict</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">opt_beamlets_PTV_margin_mm</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">opt_beamlets_PTV_margin_mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_origin_xyz_mm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">ct</span><span class="p">[</span><span class="s1">&#39;origin_xyz_mm&#39;</span><span class="p">]</span>  <span class="c1"># store ct origin from plan</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating BEV..&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocess_beams</span><span class="p">(</span><span class="n">plan_obj</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pre_process_voxels</span><span class="p">(</span>
                <span class="n">plan_obj</span><span class="o">=</span><span class="n">plan_obj</span><span class="p">)</span>  <span class="c1"># create new optimization voxel indices based on down-sample resolution</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading sparse influence matrix...&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_influence_matrix</span><span class="p">(</span><span class="n">plan_obj</span><span class="p">)</span>  <span class="c1"># create sparse influence matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse_tol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;influenceMatrixSparse_tol&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading full influence matrix..&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_influence_matrix</span><span class="p">(</span><span class="n">plan_obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full</span><span class="p">)</span>  <span class="c1"># create full matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dose_3d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vox_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vox_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="InfluenceMatrix.get_voxel_info"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_voxel_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_voxel_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_number</span><span class="p">):</span>
        <span class="n">row_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">row_number</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">row_number</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;voxel_idx&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">row_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;structures&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

            <span class="n">patch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_to_dose_voxel_map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">row_number</span><span class="p">)</span>  <span class="c1"># get dose voxel index patch</span>

            <span class="c1"># get center of patch. It should be equivalent dose voxel center</span>
            <span class="n">z_ind</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">y_ind</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">x_ind</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">patch</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">ct_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_voxel_resolution_xyz_mm&#39;</span><span class="p">]</span>
            <span class="n">ct_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_origin_xyz_mm&#39;</span><span class="p">]</span>
            <span class="n">xyz_mm</span> <span class="o">=</span> <span class="p">[</span><span class="n">ct_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_ind</span> <span class="o">*</span> <span class="n">ct_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ct_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_ind</span> <span class="o">*</span> <span class="n">ct_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ct_orig</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z_ind</span> <span class="o">*</span> <span class="n">ct_res</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">row_dict</span><span class="p">[</span><span class="s1">&#39;position_xyz_mm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz_mm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid row number </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row_number</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">row_dict</span></div>

<div class="viewcode-block" id="InfluenceMatrix.get_beamlet_info"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_beamlet_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_beamlet_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_number</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param col_number: col number/beamlet number in influence matrix</span>
<span class="sd">        :return: dictionary containing information about the beamlet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">col_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">col_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;start_beamlet&#39;</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;end_beamlet&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">prev_beam_beamlet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;end_beamlet&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev_beam_beamlet</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">col_dict</span><span class="p">[</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span>
                <span class="n">col_dict</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">col_number</span> <span class="o">-</span> <span class="n">prev_beam_beamlet</span><span class="p">]</span>
                <span class="n">col_dict</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">col_number</span> <span class="o">-</span> <span class="n">prev_beam_beamlet</span><span class="p">]</span>
                <span class="n">col_dict</span><span class="p">[</span><span class="s1">&#39;width_mm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">col_number</span> <span class="o">-</span> <span class="n">prev_beam_beamlet</span><span class="p">]</span>
                <span class="n">col_dict</span><span class="p">[</span><span class="s1">&#39;height_mm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">col_number</span> <span class="o">-</span> <span class="n">prev_beam_beamlet</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">col_dict</span></div>

<div class="viewcode-block" id="InfluenceMatrix.dose_1d_to_3d"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.dose_1d_to_3d">[docs]</a>    <span class="k">def</span> <span class="nf">dose_1d_to_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sol</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dose_1d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create 3d dose_1d from dose_1d in 1d voxels. 3d array have same resolution as CT</span>

<span class="sd">        :param sol: solution dictionary from optimization</span>
<span class="sd">        :param dose_1d: dose_1d in 1d. Optional</span>
<span class="sd">        :return: dose_1d in 3d</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dose_vox_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_to_dose_voxel_map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># dose_1d = my_plan.opt_voxels_dict[&#39;dose_1d&#39;]</span>
        <span class="k">if</span> <span class="n">dose_1d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dose_1d&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
                <span class="n">dose_1d</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;inf_matrix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;optimal_intensity&#39;</span><span class="p">]</span>  <span class="c1"># multiply it with num fractions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dose_1d</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;dose_1d&#39;</span><span class="p">]</span>
        <span class="n">dose_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">dose_vox_map</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dose_vox_map</span><span class="p">[</span><span class="n">dose_vox_map</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dose_vox_map</span><span class="p">,</span> <span class="n">inds</span><span class="p">))</span>
        <span class="n">dose_3d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">dose_1d</span><span class="p">[</span><span class="n">dose_vox_map</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dose_3d</span> <span class="o">=</span> <span class="n">dose_3d</span>
        <span class="k">return</span> <span class="n">dose_3d</span></div>

<div class="viewcode-block" id="InfluenceMatrix.dose_3d_to_1d"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.dose_3d_to_1d">[docs]</a>    <span class="k">def</span> <span class="nf">dose_3d_to_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dose_3d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get dose_1d in 1d voxels for the given influence matrix from 3d dose_1d</span>

<span class="sd">        :param dose_3d: 3d dose_1d</span>
<span class="sd">        :return: dose_1d in 1d voxel indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dose_vox_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_to_dose_voxel_map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dose_3d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dose_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dose_3d</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dose_vox_map</span><span class="p">[</span><span class="n">dose_vox_map</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">dose_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">dose_vox_map</span><span class="p">,</span> <span class="n">inds</span><span class="p">))</span>
        <span class="n">dose_1d</span><span class="p">[</span><span class="n">dose_vox_map</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dose_3d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dose_1d</span></div>

<div class="viewcode-block" id="InfluenceMatrix.fluence_2d_to_1d"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.fluence_2d_to_1d">[docs]</a>    <span class="k">def</span> <span class="nf">fluence_2d_to_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fluence_2d</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create vector of intensities from 2d fluence maps</span>

<span class="sd">        :param fluence_2d: 2d fluence as list of nd array with same length as number of beams_dict</span>
<span class="sd">        :return: fluence in 1d for beamlet indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fluence_1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">)):</span>
            <span class="n">maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;beamlet_idx_2dgrid&#39;</span><span class="p">]</span>
            <span class="n">numRows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># wMaps = np.zeros((numRows, numCols))</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numRows</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCols</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">maps</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">curr</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                        <span class="n">fluence_1d</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">fluence_2d</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fluence_1d</span></div>

<div class="viewcode-block" id="InfluenceMatrix.fluence_1d_to_2d"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.fluence_1d_to_2d">[docs]</a>    <span class="k">def</span> <span class="nf">fluence_1d_to_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fluence_1d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sol</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create 2d fluence maps from vector of intensities.</span>

<span class="sd">        :param fluence_1d: 2d fluence as vector</span>
<span class="sd">        :param sol: solution from optimization</span>
<span class="sd">        :return: 2d fluence as a list for each beam</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fluence_1d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fluence_1d</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="s1">&#39;optimal_intensity&#39;</span><span class="p">]</span>

        <span class="n">wMaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">)):</span>
            <span class="n">maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;beamlet_idx_2dgrid&#39;</span><span class="p">]</span>
            <span class="n">numRows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">wMaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span><span class="p">)))</span>
            <span class="c1"># wMaps = np.zeros((numRows, numCols))</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numRows</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCols</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">maps</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">curr</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                        <span class="n">wMaps</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">fluence_1d</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span>
                        <span class="c1"># wMaps[r, c] = optimal_intensity[curr]</span>

        <span class="k">return</span> <span class="n">wMaps</span></div>

<div class="viewcode-block" id="InfluenceMatrix.get_influence_matrix"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_influence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_influence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">is_full</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load influence matrix based on the beamlets and voxels.</span>
<span class="sd">        :param plan: object of class Plan</span>
<span class="sd">        :param is_full: get full or sparse matrix. Default to True.</span>
<span class="sd">        :return: full or sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_full</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inf_matrix_sparse</span> <span class="o">=</span> <span class="n">plan</span><span class="o">.</span><span class="n">inf_matrix</span><span class="o">.</span><span class="n">A</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inf_matrix_sparse</span> <span class="o">=</span> <span class="n">plan</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;influenceMatrixSparse&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">)):</span>
                <span class="c1"># ind = my_plan.beamlets_dict[&#39;ID&#39;].index(beam_id)</span>
                <span class="c1"># beamlet_idx_2dgrid = my_plan.get_beamlet_idx_2dgrid(beam_id=beam_id)</span>
                <span class="c1"># opt_beamlets = beamlet_idx_2dgrid[beamlet_idx_2dgrid &gt;= 0]</span>
                <span class="n">opt_beamlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;opt_beamlets_ids&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parsing influence matrix for beam </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                        <span class="c1"># inf_matrix = lil_matrix((influenceMatrixSparse[ind].shape[0], len(opt_beamlets)))</span>
                        <span class="c1"># inf_matrix = sparse.hstack([csr_matrix(influenceMatrixSparse[ind][:, np.unique(opt_beamlets[i])].sum(axis=1)) for i in range(len(opt_beamlets))], format=&#39;csr&#39;)</span>
                        <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">inf_matrix_sparse</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                             <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">))],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
                        <span class="c1"># for i in range(len(opt_beamlets)):</span>
                        <span class="c1">#     inf_matrix[:, i] = influenceMatrixSparse[ind][:, np.unique(opt_beamlets[i])].sum(axis=1)</span>
                        <span class="c1"># inf_matrix = np.vstack([np.sum(influenceMatrixSparse[ind][:, opt_beamlets[n]], 1) for n in range(len(opt_beamlets))]).T</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">inf_matrix_sparse</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="n">opt_beamlets</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parsing influence matrix for beam </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                        <span class="n">inf_matrix_2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">inf_matrix_sparse</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                             <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">))],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
                        <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">inf_matrix</span><span class="p">,</span> <span class="n">inf_matrix_2</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">inf_matrix</span><span class="p">,</span> <span class="n">inf_matrix_sparse</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="n">opt_beamlets</span><span class="p">]],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
            <span class="c1"># if del_org_matrix:</span>
            <span class="k">if</span> <span class="s1">&#39;influenceMatrixSparse&#39;</span> <span class="ow">in</span> <span class="n">plan</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">plan</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;influenceMatrixSparse&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&lt;=</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&lt;=</span> <span class="mf">2.5</span><span class="p">:</span>
                    <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">inf_matrix_sparse</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;creating influence matrix for down sample voxels..&#39;</span><span class="p">)</span>
                <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vox_weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inf_matrix</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vox_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                     <span class="k">for</span> <span class="n">i</span>
                     <span class="ow">in</span>
                     <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vox_map</span><span class="p">))],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inf_matrix_full</span> <span class="o">=</span> <span class="n">plan</span><span class="o">.</span><span class="n">inf_matrix</span><span class="o">.</span><span class="n">A_full</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inf_matrix_full</span> <span class="o">=</span> <span class="n">plan</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;influenceMatrixFull&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">)):</span>
                <span class="n">opt_beamlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;opt_beamlets_ids&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parsing full influence matrix for beam </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                        <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">inf_matrix_full</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                             <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">))])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">inf_matrix_full</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="n">opt_beamlets</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parsing full influence matrix for beam </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                        <span class="n">inf_matrix_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">inf_matrix_full</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                             <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">opt_beamlets</span><span class="p">))])</span>
                        <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">inf_matrix</span><span class="p">,</span> <span class="n">inf_matrix_2</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">inf_matrix</span><span class="p">,</span> <span class="n">inf_matrix_full</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="n">opt_beamlets</span><span class="p">]])</span>

                <span class="c1"># down sampling voxels</span>
            <span class="k">if</span> <span class="s1">&#39;influenceMatrixFull&#39;</span> <span class="ow">in</span> <span class="n">plan</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">plan</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;influenceMatrixFull&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&lt;=</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&lt;=</span> <span class="mf">2.5</span><span class="p">:</span>
                    <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">inf_matrix_full</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;creating influence matrix for down sample voxels..&#39;</span><span class="p">)</span>
                <span class="n">inf_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vox_weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inf_matrix</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vox_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vox_map</span><span class="p">))])</span>

        <span class="k">return</span> <span class="n">inf_matrix</span></div>

<div class="viewcode-block" id="InfluenceMatrix.create_BEV_mask_from_contours"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.create_BEV_mask_from_contours">[docs]</a>    <span class="k">def</span> <span class="nf">create_BEV_mask_from_contours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan_obj</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">structure</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;PTV&#39;</span><span class="p">,</span>
                                      <span class="n">margin_mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Since beams object contain projection of structure contours on BEV, this function helps to create mask from those contours on BEV</span>

<span class="sd">        :param plan_obj: object of class Plan</span>
<span class="sd">        :param ind: indices of the beam in beamlet dictionary</span>
<span class="sd">        :param structure: structure for which contours to be converted to mask</span>
<span class="sd">        :param margin_mm: expand the contours in mm. defaults to None. If it is not none, it will expand the contours</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">margin_mm</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">structure</span> <span class="o">==</span> <span class="s1">&#39;PTV&#39;</span><span class="p">:</span>
            <span class="n">margin_mm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_beamlets_PTV_margin_mm</span>
        <span class="k">elif</span> <span class="n">margin_mm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">margin_mm</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># get PTV contour from data</span>
        <span class="n">contours</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">beams</span><span class="o">.</span><span class="n">beams_dict</span><span class="p">[</span><span class="s1">&#39;BEV_structure_contour_points&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">][</span><span class="n">structure</span><span class="p">]</span>
        <span class="c1"># ind = my_plan.beamlets_dict[&#39;ID&#39;].index(beam_id)</span>
        <span class="c1"># contours = my_plan._beams_contours[ind][structure]</span>

        <span class="c1"># for each contour create polygon and get beamlets inside the polygon and create mask for it</span>
        <span class="k">for</span> <span class="n">count_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">contours</span><span class="p">)):</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">[</span><span class="n">count_num</span><span class="p">]:</span>
                <span class="n">polygon</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">LinearRing</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="c1"># add margin_mm around polygon</span>
            <span class="k">if</span> <span class="n">margin_mm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">shapely_poly</span> <span class="o">=</span> <span class="n">s</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shapely_poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">margin_mm</span><span class="p">),</span> <span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="c1">#             poly_coordinates = np.array(list(t.exterior.coords))</span>

            <span class="c1"># create beam map from beamlet coordinates and mask the beamlets inside shapely polygon</span>
            <span class="n">beamlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">x_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x_min_max_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_positions</span><span class="p">))</span>
            <span class="n">y_max_min_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y_positions</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">x_coord</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">y_coord</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">))</span>
            <span class="n">valid_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">valid_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">shapely_poly</span><span class="o">.</span><span class="n">contains</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span>
            <span class="n">x_and_y</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">valid_points</span><span class="p">]</span>
            <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_min_max_sort</span><span class="p">,</span> <span class="n">y_max_min_sort</span><span class="p">)</span>
            <span class="n">w_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x_positions</span><span class="p">,</span> <span class="n">y_positions</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">count_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">w_all</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">XX</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w_all</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">YY</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># if (beamlets[ind][&#39;position_x_mm&#39;], beamlets[ind][&#39;position_y_mm&#39;]) in x_and_y:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">ind</span><span class="p">],</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">ind</span><span class="p">])</span> <span class="ow">in</span> <span class="n">x_and_y</span><span class="p">:</span>
                        <span class="c1"># beam_map[row, col] = beamlets[ind][&#39;id&#39;]</span>
                        <span class="n">mask</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="InfluenceMatrix.preprocess_beams"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.preprocess_beams">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan_obj</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;PTV&#39;</span><span class="p">,</span> <span class="n">remove_corner_beamlets</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess beams to create beamlets dictionary based on beamlet resolution.</span>

<span class="sd">        :param plan_obj: object of class Plan</span>
<span class="sd">        :param structure: projection of the structure on BEV for which beamlets to be considered for creating influence matrix. defaults to PTV</span>
<span class="sd">        :param remove_corner_beamlets: If remove corner beamlet is true, it will remove the corner beamlets during down sampling.</span>
<span class="sd">        :return: beamlets for processing influence matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">)):</span>
            <span class="c1"># ind = my_plan.beamlets_dict[&#39;ID&#39;].index(beam_id)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_BEV_mask_from_contours</span><span class="p">(</span><span class="n">plan_obj</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">,</span>
                                                      <span class="n">margin_mm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_beamlets_PTV_margin_mm</span><span class="p">)</span>
            <span class="n">beam_2d_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_beamlet_idx_2d_grid</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">beamlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

            <span class="c1"># creating beam_map of original resolution so that mask can be multiplied with it</span>
            <span class="n">beam_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_orig_res_2d_grid</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">beam_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">beam_map</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">mask</span><span class="p">)</span>  <span class="c1"># add and subtract one to maintain 0th beamlet</span>
            <span class="n">beam_map</span> <span class="o">=</span> <span class="n">beam_map</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># subtract one again to get original beamlets</span>

            <span class="c1"># get mask and beam_map in 2.5mm resolution</span>
            <span class="n">beamlet_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">beam_map</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">beamlet_ind</span> <span class="o">=</span> <span class="n">beamlet_ind</span><span class="p">[</span><span class="n">beamlet_ind</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">beam_2d_grid</span><span class="p">,</span> <span class="n">beamlet_ind</span><span class="p">))</span>
            <span class="n">mask_2d_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">beam_2d_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">mask_2d_grid</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">beam_2d_grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">beam_2d_grid</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">mask_2d_grid</span>  <span class="c1"># add and subtract 1 to retain ids</span>
            <span class="n">beam_2d_grid</span> <span class="o">=</span> <span class="n">beam_2d_grid</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">beam_map</span> <span class="o">=</span> <span class="n">beam_2d_grid</span>

            <span class="c1"># get opt beamlets for down_sample grid as list of original inf_matrix beamlet</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">:</span>
                <span class="n">down_sample_2d_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_2d_grid</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="p">,</span> <span class="n">beamlet_width_mm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span><span class="p">,</span>
                                                               <span class="n">beamlet_height_mm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span><span class="p">)</span>
                <span class="n">down_sample_2d_grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">down_sample_2d_grid</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">mask_2d_grid</span>  <span class="c1"># add and subtract 1 to retain ids</span>
                <span class="n">down_sample_2d_grid</span> <span class="o">=</span> <span class="n">down_sample_2d_grid</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">down_sample_beamlets</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">down_sample_2d_grid</span><span class="p">[</span><span class="n">down_sample_2d_grid</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]),</span>
                                                         <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># remove corner beamlets in coarse resolution and updating down sample map</span>
                <span class="k">if</span> <span class="n">remove_corner_beamlets</span><span class="p">:</span>
                    <span class="n">count_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">/</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">/</span> <span class="mf">2.5</span><span class="p">))</span>
                    <span class="n">down_sample_beamlets</span> <span class="o">=</span> <span class="n">down_sample_beamlets</span><span class="p">[</span><span class="n">count_ind</span><span class="p">]</span>
                    <span class="c1"># updating down sample grid after removing corner beamlets</span>
                    <span class="n">inds_down_sample</span> <span class="o">=</span> <span class="n">down_sample_2d_grid</span> <span class="o">==</span> <span class="n">down_sample_beamlets</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span>
                                                              <span class="kc">None</span><span class="p">]</span>  <span class="c1"># keep only down sample beamlets and remove others</span>
                    <span class="n">down_sample_2d_grid</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">inds_down_sample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">down_sample_2d_grid</span><span class="p">,</span> <span class="n">down_sample_beamlets</span><span class="p">))</span>
                <span class="n">mask_2d_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">beam_2d_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">mask_2d_grid</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># actual_beamlets = beam_2d_grid[a]</span>
                <span class="n">actual_beamlets</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">inf_matrix</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;beamlet_idx_2dgrid&#39;</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
                <span class="n">sampled_beamlets</span> <span class="o">=</span> <span class="n">down_sample_2d_grid</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sampled_beamlets</span> <span class="o">==</span> <span class="n">down_sample_beamlets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">down_sample_beamlets</span><span class="p">))]</span>
                <span class="n">opt_beamlets</span> <span class="o">=</span> <span class="p">[</span><span class="n">actual_beamlets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>

                <span class="n">beam_map</span> <span class="o">=</span> <span class="n">down_sample_2d_grid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">opt_beamlets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">beam_map</span><span class="p">[</span><span class="n">beam_map</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]))</span>

            <span class="c1"># make beamlets continuous</span>
            <span class="n">std_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_beamlets</span><span class="p">(</span><span class="n">beam_map</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">beam_map</span> <span class="o">=</span> <span class="n">std_map</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">beam_map</span> <span class="o">=</span> <span class="n">std_map</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;beamlet_idx_2dgrid&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mask_2d_grid</span>
            <span class="n">standInd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">beam_map</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;beamlet_idx_2dgrid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">beam_map</span>
            <span class="c1"># my_plan.beamlets_dict.setdefault(&#39;structure_mask_2dgrid&#39;, []).append(mask_2d_grid)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;start_beamlet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">standInd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;end_beamlet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;beamlet_idx_2dgrid&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;opt_beamlets_ids&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opt_beamlets</span>

            <span class="c1"># update beamlet dict</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_width_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlet_height_mm</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">opt_beamlets</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">opt_beamlets</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">opt_beamlets</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">opt_beamlets</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;MLC_leaf_idx&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;MLC_leaf_idx&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">opt_beamlets</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="s1">&#39;id&#39;</span><span class="p">]</span></div>
            <span class="c1"># my_plan.beams_dict.setdefault(&#39;opt_beamlets_ids&#39;, []).append(standInd[1:])</span>

<div class="viewcode-block" id="InfluenceMatrix.create_beamlet_idx_2d_grid"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.create_beamlet_idx_2d_grid">[docs]</a>    <span class="k">def</span> <span class="nf">create_beamlet_idx_2d_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create beamlet idx in 2d grid of 2.5mm resolution. i.e. each element in matrix is 2.5mm*2.5mm</span>

<span class="sd">        :param ind: indices for the beam in beamlets dictionary</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ind = my_plan.beamlets_dict[&#39;ID&#39;].index(beam_id)</span>
        <span class="n">beamlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">x_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">y_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">right_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x_positions</span><span class="p">)</span>
        <span class="n">bottom_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y_positions</span><span class="p">)</span>
        <span class="n">w_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x_positions</span><span class="p">,</span> <span class="n">y_positions</span><span class="p">))</span>  <span class="c1"># top left corners of all beamlets</span>
        <span class="n">x_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_positions</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_positions</span><span class="p">)</span> <span class="o">+</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">right_ind</span><span class="p">],</span> <span class="mf">2.5</span><span class="p">)</span>
        <span class="n">y_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_positions</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_positions</span><span class="p">)</span> <span class="o">-</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">bottom_ind</span><span class="p">],</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">)</span>
        <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">)</span>
        <span class="n">beamlet_idx_2d_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">beamlet_idx_2d_grid</span> <span class="o">=</span> <span class="n">beamlet_idx_2d_grid</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">w_all</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">XX</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w_all</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">YY</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">num_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.5</span><span class="p">)</span>
                    <span class="n">num_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.5</span><span class="p">)</span>
                    <span class="n">beamlet_idx_2d_grid</span><span class="p">[</span><span class="n">row</span><span class="p">:</span><span class="n">row</span> <span class="o">+</span> <span class="n">num_height</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span><span class="n">col</span> <span class="o">+</span> <span class="n">num_width</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>

        <span class="k">return</span> <span class="n">beamlet_idx_2d_grid</span></div>

<div class="viewcode-block" id="InfluenceMatrix.down_sample_2d_grid"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.down_sample_2d_grid">[docs]</a>    <span class="k">def</span> <span class="nf">down_sample_2d_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">beamlet_width_mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
                            <span class="n">beamlet_height_mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create down sample beam map based on beamlet width and height</span>

<span class="sd">        :param ind: indices for the beam in beamlets dictionary</span>
<span class="sd">        :param beamlet_width_mm:</span>
<span class="sd">        :param beamlet_height_mm:</span>
<span class="sd">        :return: down sampled 2d grid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ind = my_plan.beamlets_dict[&#39;ID&#39;].index(beam_id)</span>
        <span class="n">beamlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">x_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">y_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">right_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x_positions</span><span class="p">)</span>
        <span class="n">bottom_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y_positions</span><span class="p">)</span>
        <span class="c1"># w_all = np.column_stack((x_positions, y_positions))  # top left corners of all beamlets</span>
        <span class="n">x_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_positions</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_positions</span><span class="p">)</span> <span class="o">+</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;width_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">right_ind</span><span class="p">],</span> <span class="mf">2.5</span><span class="p">)</span>
        <span class="n">y_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_positions</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_positions</span><span class="p">)</span> <span class="o">-</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;height_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">bottom_ind</span><span class="p">],</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">)</span>
        <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">)</span>
        <span class="n">beamlet_resample_2d_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">beamlet_resample_2d_grid</span> <span class="o">=</span> <span class="n">beamlet_resample_2d_grid</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row_col_covered</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># ind = np.where((w_all[:, 0] == XX[row, col]) &amp; (w_all[:, 1] == YY[row, col]))</span>
                <span class="c1"># if np.size(ind) &gt; 0:</span>
                <span class="c1">#     ind = ind[0][0]</span>
                <span class="k">if</span> <span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">row_col_covered</span><span class="p">:</span>
                    <span class="n">num_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">beamlet_width_mm</span> <span class="o">/</span> <span class="mf">2.5</span><span class="p">)</span>
                    <span class="n">num_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">beamlet_height_mm</span> <span class="o">/</span> <span class="mf">2.5</span><span class="p">)</span>
                    <span class="n">beamlet_resample_2d_grid</span><span class="p">[</span><span class="n">row</span><span class="p">:</span><span class="n">row</span> <span class="o">+</span> <span class="n">num_height</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span><span class="n">col</span> <span class="o">+</span> <span class="n">num_width</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="n">num_height</span><span class="p">)</span>
                    <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">num_width</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
                        <span class="n">row_col_covered</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">beamlet_resample_2d_grid</span></div>

<div class="viewcode-block" id="InfluenceMatrix.get_orig_res_2d_grid"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_orig_res_2d_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_orig_res_2d_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create beam map 2d grid in the original resolution where each element in matrix is the size of respective beamlet.</span>

<span class="sd">        :param ind: indices for the beam in beamlets dictionary</span>
<span class="sd">        :return: beam map 2d grid in original resolution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beamlets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">x_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_x_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_positions</span> <span class="o">=</span> <span class="n">beamlets</span><span class="p">[</span><span class="s1">&#39;position_y_mm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_min_max_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_positions</span><span class="p">))</span>
        <span class="n">y_max_min_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y_positions</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_min_max_sort</span><span class="p">,</span> <span class="n">y_max_min_sort</span><span class="p">)</span>
        <span class="n">w_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x_positions</span><span class="p">,</span> <span class="n">y_positions</span><span class="p">))</span>
        <span class="n">beam_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">b_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">w_all</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">XX</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w_all</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">YY</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># beam_map[row, col] = beamlets[ind][&#39;id&#39;]+int(1)# adding one so that 0th beamlet is retained</span>
                <span class="n">beam_map</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_ind</span>  <span class="c1"># + int(1)  # adding one so that 0th beamlet is retained</span>
        <span class="c1"># beam_map = np.multiply(beam_map, mask)</span>
        <span class="c1"># beam_map = beam_map - int(1)  # subtract one again to get original beamlets</span>
        <span class="k">return</span> <span class="n">beam_map</span></div>

<div class="viewcode-block" id="InfluenceMatrix.get_bev_2d_grid"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_bev_2d_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_bev_2d_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">finest_grid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get BEV in 2d grid in original resolution where beamlet index is the column number in influence matrix</span>

<span class="sd">        :param ind: idx of the beam in beamlets_dict.</span>
<span class="sd">        It can be int or List[int]. If int, ndarray is return, If List[int], list[ndarray] is returned</span>
<span class="sd">        :param beam_id: beam_id of the beam.</span>
<span class="sd">        It can be int or List[int]. If int, ndarray is return, If List[int], list[ndarray] is returned</span>
<span class="sd">        :param finest_grid:Default to False. If set to true, it will return 2d grid in finest resolution</span>
<span class="sd">        :return: ndarray/List[ndarray]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">beam_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beam_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">))</span> <span class="k">if</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">beam_id</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ind</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid beam id </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">beam_id</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beam_id</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">beam_id</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ind_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">))</span> <span class="k">if</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind_1</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid beam id </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="c1"># Bug fix. in case ind is int make it as list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">beam_orig</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
            <span class="n">beam_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="s1">&#39;beamlet_idx_2dgrid&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">finest_grid</span><span class="p">:</span>
                <span class="n">rowsNoRepeat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">beam_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">beam_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="n">beam_map</span><span class="p">[</span><span class="n">rowsNoRepeat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="n">rowsNoRepeat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">colsNoRepeat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">beam_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">beam_map</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">beam_map</span><span class="p">[:,</span> <span class="n">colsNoRepeat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="n">colsNoRepeat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">beam_map</span> <span class="o">=</span> <span class="n">beam_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rowsNoRepeat</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">colsNoRepeat</span><span class="p">))]</span>
            <span class="n">beam_orig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beam_map</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">beam_orig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">beam_orig</span> <span class="o">=</span> <span class="n">beam_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># return ndarray in case if it is not list</span>

        <span class="k">return</span> <span class="n">beam_orig</span></div>

<div class="viewcode-block" id="InfluenceMatrix.down_sample_voxels"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.down_sample_voxels">[docs]</a>    <span class="k">def</span> <span class="nf">down_sample_voxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">down_sample_xyz</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method creates new ct to dose_1d voxel map array based on down sampled voxels.</span>
<span class="sd">        It also outputs map between down sampled voxel indices to original voxel indices for down sampling influence matrix</span>
<span class="sd">        :param down_sample_xyz: It down-samples optimization voxels as factor of ct resolution</span>
<span class="sd">                e.g. down_sample_xyz = [5,5,1]. It will down-sample optimization voxels with 5 * ct res. in x direction, 5 * ct res. in y direction and 1*ct res. in z direction.</span>
<span class="sd">                defaults to None. When None it will use the original optimization voxel resolution.</span>
<span class="sd">        :return: voxel map(list containing map between down-sampled indices to original indices), voxel weight (weighted average of voxels in down sample</span>
<span class="sd">         and ct to dose_1d voxel map</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vox_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_to_dose_voxel_map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># dose_to_ct_int = np.round(np.array(self.opt_voxels_dict[&#39;dose_voxel_resolution_xyz_mm&#39;]) /</span>
        <span class="c1">#                           np.array(self.opt_voxels_dict[&#39;ct_voxel_resolution_xyz_mm&#39;]))</span>
        <span class="c1"># dose_to_ct_int = dose_to_ct_int.astype(int)</span>

        <span class="c1"># using patchify</span>
        <span class="n">use_patchify</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">use_patchify</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reindexing voxels...&#39;</span><span class="p">)</span>
            <span class="n">vox_map</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vox_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">slices</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="n">patchify</span><span class="p">(</span><span class="n">vox_3d</span><span class="p">,</span> <span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">step</span><span class="o">=</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
            <span class="c1"># pat = np.vstack(patches)</span>
            <span class="c1"># pat = np.vstack(pat)</span>
            <span class="n">pat</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">vox_inds</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># calculate weight for each voxel</span>
                    <span class="c1"># vox_map[vox_inds] = np.column_stack((vox_inds, count * np.ones_like(vox_inds), weight))</span>
                    <span class="n">vox_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox_inds</span><span class="p">)</span>
                    <span class="n">vox_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                    <span class="c1"># pat[i] = np.ones((1, 5, 5), dtype=int)*int(count)</span>
                    <span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">unfold_shape</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">output_c</span> <span class="o">=</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">output_h</span> <span class="o">=</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">output_w</span> <span class="o">=</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">pat_reshape</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">patches</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">down_sample_3d</span> <span class="o">=</span> <span class="n">pat_reshape</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">output_c</span><span class="p">,</span> <span class="n">output_h</span><span class="p">,</span> <span class="n">output_w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">down_sample_3d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">vox_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">down_sample_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">down_sample_3d</span><span class="p">,</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vox_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">down_sample_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">down_sample_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">))],</span>
                    <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># using pytorch</span>
        <span class="n">use_torch</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">use_torch</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">torch</span>
            <span class="n">vox_map</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vox_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vox_3d_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">vox_3d</span><span class="p">)</span>
            <span class="n">kc</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">kw</span> <span class="o">=</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># xyz kernel size</span>
            <span class="n">dc</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">down_sample_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># xyz stride</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="n">vox_3d_torch</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">kw</span><span class="p">,</span> <span class="n">dw</span><span class="p">)</span>
            <span class="n">unfold_shape</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
            <span class="n">patches</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">kw</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pat</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">elem</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">pat</span><span class="p">[</span><span class="n">pat</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">vox_inds</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># calculate weight for each voxel</span>
                    <span class="c1"># vox_map[vox_inds] = np.column_stack((vox_inds, count * np.ones_like(vox_inds), weight))</span>
                    <span class="n">vox_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox_inds</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
                    <span class="n">vox_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
                    <span class="c1"># pat[i] = np.ones((1, 5, 5), dtype=int)*int(count)</span>
                    <span class="n">pat</span><span class="p">[</span><span class="n">pat</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Reshape back</span>
            <span class="n">patches_orig</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">unfold_shape</span><span class="p">)</span>
            <span class="n">output_c</span> <span class="o">=</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">output_h</span> <span class="o">=</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">output_w</span> <span class="o">=</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">unfold_shape</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">patches_orig</span> <span class="o">=</span> <span class="n">patches_orig</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
            <span class="n">down_sample_3d_torch</span> <span class="o">=</span> <span class="n">patches_orig</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">output_c</span><span class="p">,</span> <span class="n">output_h</span><span class="p">,</span> <span class="n">output_w</span><span class="p">)</span>
            <span class="n">down_sample_3d</span> <span class="o">=</span> <span class="n">down_sample_3d_torch</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">down_sample_3d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">vox_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">down_sample_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">down_sample_3d</span><span class="p">,</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vox_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">down_sample_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">down_sample_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">))],</span>
                    <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vox_map</span><span class="p">,</span> <span class="n">vox_weights</span><span class="p">,</span> <span class="n">down_sample_3d</span></div>

<div class="viewcode-block" id="InfluenceMatrix.pre_process_voxels"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.pre_process_voxels">[docs]</a>    <span class="k">def</span> <span class="nf">pre_process_voxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates opt_voxels_dict based upon ct to dose_1d voxel map</span>

<span class="sd">        :param plan_obj: object if class Plan</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vox_map</span><span class="p">,</span> <span class="n">vox_weights</span><span class="p">,</span> <span class="n">down_sample_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_sample_voxels</span><span class="p">(</span><span class="n">down_sample_xyz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">down_sample_xyz</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_to_dose_voxel_map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">down_sample_3d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vox_map</span> <span class="o">=</span> <span class="n">vox_map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vox_weights</span> <span class="o">=</span> <span class="n">vox_weights</span>
            <span class="k">for</span> <span class="n">structure_name</span> <span class="ow">in</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">structures_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">structures_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">structure_name</span><span class="p">)</span>
                <span class="n">vox_3d</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">structures_dict</span><span class="p">[</span><span class="s1">&#39;structure_mask_3d&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> \
                         <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_to_dose_voxel_map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># my_plan.structures_dict[&#39;voxel_idx&#39;][i] = np.unique(vox_3d[vox_3d &gt; 0])</span>
                <span class="n">vox</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vox_3d</span><span class="p">[</span><span class="n">vox_3d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;voxel_idx&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">vox</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;voxel_size&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
                    <span class="n">plan_obj</span><span class="o">.</span><span class="n">get_ct_res_xyz_mm</span><span class="p">())</span>  <span class="c1"># calculate weight for each voxel</span></div>
                <span class="c1"># self.opt_voxels_dict[&#39;voxel_size&#39;][ind] = counts / np.max(counts)  # calculate weight for each voxel</span>

<div class="viewcode-block" id="InfluenceMatrix.sort_beamlets"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.sort_beamlets">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sort_beamlets</span><span class="p">(</span><span class="n">b_map</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">b_map</span><span class="p">[</span><span class="n">b_map</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">c_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">matrix_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b_map</span> <span class="o">==</span> <span class="n">c_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">c_i</span> <span class="ow">in</span> <span class="n">c_sort</span><span class="p">]</span>
        <span class="n">map_copy</span> <span class="o">=</span> <span class="n">b_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
            <span class="n">map_copy</span><span class="p">[</span><span class="n">matrix_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">map_copy</span></div>

    <span class="c1"># for voxels idx methods</span>
<div class="viewcode-block" id="InfluenceMatrix.set_opt_voxel_idx"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.set_opt_voxel_idx">[docs]</a>    <span class="k">def</span> <span class="nf">set_opt_voxel_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plan_obj</span><span class="p">,</span> <span class="n">structure_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set opt_voxel_idx for the structure based upon ct_dose_voxel_map and structure mask</span>

<span class="sd">        :param plan_obj: object of class Plan</span>
<span class="sd">        :param structure_name: structure name</span>
<span class="sd">        :return: set the voxel idx in opt_voxels_dict for the structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">structures_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">structure_name</span><span class="p">)</span>
        <span class="n">vox_3d</span> <span class="o">=</span> <span class="n">plan_obj</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">structures_dict</span><span class="p">[</span><span class="s1">&#39;structure_mask_3d&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">*</span> \
                 <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;ct_to_dose_voxel_map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># my_plan.structures_dict[&#39;voxel_idx&#39;][i] = np.unique(vox_3d[vox_3d &gt; 0])</span>
        <span class="n">vox</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vox_3d</span><span class="p">[</span><span class="n">vox_3d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;voxel_idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vox</span><span class="p">)</span>
        <span class="c1"># self.opt_voxels_dict[&#39;voxel_size&#39;].append(counts / np.max(counts))  # calculate weight for each voxel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;voxel_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">counts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">plan_obj</span><span class="o">.</span><span class="n">get_ct_res_xyz_mm</span><span class="p">()))</span>  <span class="c1"># calculate weight for each voxel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structure_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="InfluenceMatrix.get_opt_voxels_idx"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_opt_voxels_idx">[docs]</a>    <span class="k">def</span> <span class="nf">get_opt_voxels_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get voxel index for structure</span>
<span class="sd">        :param structure_name: name of the structure in plan</span>
<span class="sd">        :return: voxel indexes for the structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">structure_name</span><span class="p">)</span>
        <span class="n">vox_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;voxel_idx&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span>
        <span class="c1"># vox_ind = np.where(my_plan.opt_voxels_dict[&#39;voxel_structure_map&#39;][0][:, ind] == 1)[0]</span>
        <span class="k">return</span> <span class="n">vox_ind</span></div>

<div class="viewcode-block" id="InfluenceMatrix.get_opt_voxels_size"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_opt_voxels_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_opt_voxels_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         :param structure_name: name of the structure in plan</span>
<span class="sd">         :return: voxel size for the structure</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">structure_name</span><span class="p">)</span>
        <span class="n">vox_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_voxels_dict</span><span class="p">[</span><span class="s1">&#39;voxel_size&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span>
        <span class="c1"># vox_ind = np.where(my_plan.opt_voxels_dict[&#39;voxel_structure_map&#39;][0][:, ind] == 1)[0]</span>
        <span class="k">return</span> <span class="n">vox_weights</span></div>

<div class="viewcode-block" id="InfluenceMatrix.get_all_beam_ids"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.get_all_beam_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_beam_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">ids</span></div>

<div class="viewcode-block" id="InfluenceMatrix.plot_fluence_2d"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.plot_fluence_2d">[docs]</a>    <span class="k">def</span> <span class="nf">plot_fluence_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">optimal_fluence_2d</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sol</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">                Displays fluence in 2d for the given beam_id</span>

<span class="sd">                :param optimal_fluence_2d:</span>
<span class="sd">                :param beam_id: beam_id of the beam</span>
<span class="sd">                :param sol: solution dictionary after optimization</span>
<span class="sd">                :return: 2d optimal fluence plot</span>

<span class="sd">                :Example:</span>
<span class="sd">                &gt;&gt;&gt; Visualization.plot_fluence_2d(beam_id=0, sol=sol)</span>
<span class="sd">                &quot;&quot;&quot;</span>
        <span class="c1"># getting options_fig:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;figsize&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;figsize&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;title&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;filename&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">show</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;show&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;ax&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">beam_id</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;invalid beam id </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">beam_id</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optimal_fluence_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluence_1d_to_2d</span><span class="p">(</span><span class="n">sol</span><span class="o">=</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">optimal_fluence_2d</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x-axis (beamlets column)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;y-axis (beamlets row)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="InfluenceMatrix.plot_fluence_3d"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.plot_fluence_3d">[docs]</a>    <span class="k">def</span> <span class="nf">plot_fluence_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">optimal_fluence_2d</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sol</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Displays fluence in 3d for the given beam_id</span>

<span class="sd">                :param optimal_fluence_2d:</span>
<span class="sd">                :param sol: solution after optimization</span>
<span class="sd">                :param beam_id: beam_id of the beam</span>
<span class="sd">                :return: 3d optimal fluence plot</span>

<span class="sd">                :Example:</span>
<span class="sd">                &gt;&gt;&gt; Visualization.plot_fluence_3d(beam_id=0, sol=sol)</span>
<span class="sd">                &quot;&quot;&quot;</span>

        <span class="c1"># getting options_fig:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;figsize&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;figsize&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;title&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;filename&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">show</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;show&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;ax&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;ax&#39;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beamlets_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;beam_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">beam_id</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;invalid beam id </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">beam_id</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optimal_fluence_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluence_1d_to_2d</span><span class="p">(</span><span class="n">sol</span><span class="o">=</span><span class="n">sol</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">surf</span><span class="p">)</span> <span class="o">=</span> <span class="n">InfluenceMatrix</span><span class="o">.</span><span class="n">surface_plot</span><span class="p">(</span><span class="n">optimal_fluence_2d</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                                                       <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Fluence Intensity&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x-axis (beamlets column)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;y-axis (beamlets row)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="InfluenceMatrix.surface_plot"><a class="viewcode-back" href="../../../portpy.photon.html#portpy.photon.influence_matrix.InfluenceMatrix.surface_plot">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">surface_plot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># acquire the cartesian coordinate matrices from the matrix</span>
        <span class="c1"># x is cols, y is rows</span>
        <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">))</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">surf</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Gourav Jhanwar, Mojtaba Tefagh, Vicki Trier Taasti, Sadegh Alam, Seppo Tuomaala, Saad Nadeem and Masoud Zarepisheh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>